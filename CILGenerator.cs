/*
Chimera
Date: 11-Nov-2019
Authors:
	A01371779 Andres De Lago Gomez
	A01377503 Ian Neumann Sanchez
	A01371719 Servio Tulio Reyes Castillo
*/
using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace Chimera
{

    class CILGenerator
    {
        public SymbolTable symbolTable
        {
            get;
            private set;
        }

        public ProcedureTable procedureTable
        {
            get;
            private set;
        }

        private string currentScope = "";

        private bool inLoopOrFor = false;
        private bool inAssignment = false;
        private int id = 0;
        private int currentId = 0;
        private int currentIfId = 0;

        private int currentElseCount = 0;

        private StringBuilder builder = new StringBuilder();

        public CILGenerator(SymbolTable symbolTable, ProcedureTable procedureTable)
        {
            this.symbolTable = symbolTable;
            this.procedureTable = procedureTable;
            this.builder.Clear();
        }

        public void Visit(ProgramNode node)
        {
            builder.AppendLine("// Code generated by the chimera compiler\n");
            builder.AppendLine(".assembly 'Chimera' {}");
            builder.AppendLine(".assembly extern 'ChimeraLib' {}");
            builder.AppendLine(".class public 'ChimeraProgram' extends ['mscorlib']'System'.'Object' {");
            VisitChildren(node);
            builder.AppendLine("}");
        }
        public void Visit(StatementListNode node)
        {
            VisitChildren(node);
        }

        public void Visit(AndNode node)
        {
            VisitBinaryOperator(node, Type.BOOL);
            builder.AppendLine("\t\tand");
        }
        public void Visit(OrNode node)
        {
            VisitBinaryOperator(node, Type.BOOL);
            builder.AppendLine("\tor");
        }
        public void Visit(XorNode node)
        {
            VisitBinaryOperator(node, Type.BOOL);
            builder.AppendLine("\txor");
        }
        public void Visit(NotNode node)
        {
            if (Visit((dynamic)node[0]) != Type.BOOL)
            {
                throw new SemanticError(
                    $"Operator {node.AnchorToken.Lexeme} requires an operand of type {Type.BOOL}",
                    node.AnchorToken);
            }
            builder.AppendLine("not");
        }

        public void Visit(EqualNode node)
        {
            VisitBinaryIntOrBoolOperator(node);
            builder.AppendLine("ceq");
        }
        public void Visit(UnequalNode node)
        {
            VisitBinaryIntOrBoolOperator(node);
            builder.AppendLine("ceq");
            builder.AppendLine("not");
        }

        public void Visit(LessThanNode node)
        {
            VisitBinaryOperator(node, Type.INT);
            builder.AppendLine("clt");
        }
        public void Visit(MoreThanNode node)
        {
            VisitBinaryOperator(node, Type.INT);
            builder.AppendLine("cgt");
        }
        public void Visit(LessThanEqualNode node)
        {
            VisitBinaryOperator(node, Type.INT);
            builder.AppendLine("cgt");
            builder.AppendLine("not");
        }
        public void Visit(MoreThanEqualNode node)
        {
            VisitBinaryOperator(node, Type.INT);
            builder.AppendLine("clt");
            builder.AppendLine("not");
        }

        public void Visit(MinusNode node)
        {
            VisitBinaryOperator(node, Type.INT);
            builder.AppendLine("sub.ovf");
        }
        public void Visit(PlusNode node)
        {
            VisitBinaryOperator(node, Type.INT);
            builder.AppendLine("add.ovf");
        }
        public void Visit(TimesNode node)
        {
            VisitBinaryOperator(node, Type.INT);
            builder.AppendLine("mul.ovf");
        }
        public void Visit(DivNode node)
        {
            VisitBinaryOperator(node, Type.INT);
            builder.AppendLine("div");
        }
        public void Visit(RemNode node)
        {
            VisitBinaryOperator(node, Type.INT);
            builder.AppendLine("rem");
        }

        public void Visit(IntegerNode node)
        {
            builder.AppendLine("int32");
        }
        public void Visit(StringNode node)
        {
            builder.AppendLine("string");
        }
        public void Visit(BooleanNode node)
        {
            builder.Append("int32");
        }
        public void Visit(VoidTypeNode node)
        {
            builder.Append("void");
        }
        public void Visit(ListTypeNode node)
        {
            Visit((dynamic)Node.fromToken(node.AnchorToken));
            builder.Append("[]");
        }

        public void Visit(IntLiteralNode node)
        {
            var intStr = node.AnchorToken.Lexeme;
            try
            {
                builder.AppendLine($"ldc.i4 {intStr}");
            }
            catch (OverflowException)
            {
                throw new SemanticError(
                    $"Integer literal too large: {intStr}",
                    node.AnchorToken);
            }
        }
        public void Visit(StringLiteralNode node)
        {
            var str = node.AnchorToken.Lexeme;
            builder.AppendLine($"ldstr \"{str}\"");
        }
        public void Visit(BoolLiteralNode node)
        {
            var str = node.AnchorToken.Lexeme;
            var value = str == "true" ? 1 : 0;
            builder.AppendLine($"ldc.i4.{value}");
        }
        public void Visit(ListLiteralNode node)
        {
            builder.AppendLine($"ldc.i4 {node.Count()}");
            builder.AppendLine($"newarr");
            int index = 0;
            foreach (var n in node)
            {
                builder.AppendLine("dup");
                builder.AppendLine($"ldc.i4 {index}");
                Visit((dynamic)n);
                builder.AppendLine("stelem.ref");
                index++;
            }
        }

        public void Visit(ListIndexNode node)
        {
            Visit((dynamic)node[0]);
            Visit((dynamic)node[1]);

            if (!inAssignment)
            {
                builder.AppendLine("ldelem.ref");
            }
        }

        public void Visit(ConstantListNode node)
        {
            VisitChildren(node);
        }
        public void Visit(ConstantDeclarationNode node)
        {
            var varName = node.AnchorToken.Lexeme;
            Type varType = GetSymbol(varName).type;
            string cilType = GetCilType(varType);
            builder.Append($".field public static {cilType} '{varName}'");

        }
        public void Visit(VariableDeclarationNode node)
        {
            foreach (var typeNode in node)
            {
                foreach (var idNode in typeNode)
                {
                    var varName = idNode.AnchorToken.Lexeme;
                    Type varType = GetSymbol(varName).type;
                    string cilType = GetCilType(varType);

                    if (currentScope == "")
                    {
                        builder.AppendLine($".field public static {cilType} '{varName}'");
                    }
                    else
                    {
                        builder.AppendLine($"{cilType} '{varName}'");
                    }
                }
            }
        }

        public void Visit(AssignmentNode node)
        {
            inAssignment = true;
            Visit((dynamic)node[0]);
            inAssignment = false;
            Visit((dynamic)node[1]);
            if (node[0] is ListIndexNode)
            {
                builder.AppendLine("stelem.ref");
            }
            else
            {
                string varName = node[0].AnchorToken.Lexeme;
                if (symbolTable.Contains(varName))
                {
                    builder.AppendLine($"stsfld class ['chimera']'ChimeraProgram'::{varName}");
                }
                else
                {
                    builder.AppendLine($"stloc {varName}");
                }
            }
        }
        public void Visit(IdentifierNode node)
        {
            string varName = node.AnchorToken.Lexeme;

            if (!inAssignment)
            {
                var symbol = GetSymbol(varName);
                if (symbol.kind == Kind.PARAM)
                {
                    builder.AppendLine($"ldarg {varName}");
                }
                else if (symbolTable.Contains(varName))
                {
                    builder.AppendLine($"ldstfld class ['chimera']'ChimeraProgram'::{varName}");
                }
                else
                {
                    builder.AppendLine($"ldloc {varName}");
                }
            }
        }

        public void Visit(LoopStatementNode node)
        {
            var lastInLoopOrFor = inLoopOrFor;
            var lastId = currentId;
            currentId = id++;
            builder.AppendLine($"loop_{currentId}:");
            inLoopOrFor = true;
            VisitChildren(node);
            builder.Append($"end_{currentId}");

            inLoopOrFor = lastInLoopOrFor;
            currentId = lastId;
        }
        public void Visit(ForStatementNode node)
        {
            string varName = node[0].AnchorToken.Lexeme;
            var lastInLoopOrFor = inLoopOrFor;
            inLoopOrFor = true;
            builder.AppendLine("ldc.i4.0");
            builder.AppendLine($"stloc '__{varName}_index'");
            Visit((dynamic)node[1]);

            builder.AppendLine($"for_{currentId}:");
            Visit((dynamic)node[2]);

            builder.AppendLine($"ldloc '__{varName}_index'");
            builder.AppendLine("ldc.i4.1");
            builder.AppendLine("add");
            builder.AppendLine($"stloc '__{varName}_index'");

            builder.AppendLine($"next_{currentId}:");
            builder.AppendLine($"ldloc '__{varName}_index'");
            builder.AppendLine($"blt for_{currentId}");

            builder.AppendLine($"end_{currentId}:");
            inLoopOrFor = lastInLoopOrFor;
        }
        public void Visit(ExitNode node)
        {
            builder.AppendLine($"br end_{currentId}");
        }

        public void Visit(IfStatementNode node)
        {
            currentIfId = id++;
            int previousElseCount = currentElseCount;
            currentElseCount = 0;

            Visit((dynamic)node[0]);
            builder.AppendLine($"brzero If_{currentIfId}_1");
            builder.AppendLine($"If_{currentIfId}_0:");
            Visit((dynamic)node[1]);
            builder.AppendLine($"br If_{currentIfId}_End");
            VisitChildren(node, 2);
            builder.AppendLine($"If_{currentIfId}_{currentElseCount + 1}:");
            builder.AppendLine($"If_{currentIfId}_End:");

            currentElseCount = previousElseCount;
        }
        public void Visit(ElseIfListNode node)
        {
            VisitChildren(node);
        }
        public void Visit(ElifStatementNode node)
        {
            currentElseCount++;
            Visit((dynamic)node[0]);
            builder.AppendLine($"brzero If_{currentIfId}_{currentElseCount + 1}");
            builder.AppendLine($"If_{currentIfId}_{currentElseCount}:");
            VisitChildren(node, 1);
            builder.AppendLine($"If_{currentIfId}_End:");
        }
        public void Visit(ElseStatementNode node)
        {
            currentElseCount++;
            builder.AppendLine($"If_{currentIfId}_{currentElseCount}:");
            VisitChildren(node);
            builder.AppendLine($"If_{currentIfId}_End:");
        }

        public void Visit(ProcedureListNode node)
        {
            VisitChildren(node);
        }
        public void Visit(ProcedureDeclarationNode node)
        {
            var procedureName = node.AnchorToken.Lexeme;
            Type type = GetSymbol(procedureName).type;
            string returnType = GetCilType(type);
            builder.Append($".method public static {returnType} '{procedureName}'(");
            Visit((dynamic)node[1]);
            builder.AppendLine("){");

            currentScope = procedureName;
            VisitChildren(node, 3);
            currentScope = "";

            builder.AppendLine("}");
        }
        public void Visit(ParameterDeclarationNode node)
        {
            foreach (var typeNode in node)
            {
                foreach (var idNode in typeNode)
                {
                    var varName = idNode.AnchorToken.Lexeme;
                    Type type = GetSymbol(varName).type;
                    string cilType = GetCilType(type);
                    builder.AppendLine($"{cilType} {varName}");
                }
            }
        }
        public void Visit(ReturnStatementNode node)
        {
            bool returnsSomething = node.Count() != 0;
            string procedureName = currentScope;
            Type returnType = GetSymbol(procedureName).type;

            if (returnsSomething)
            {
                Visit((dynamic)node[0]);
            }
            else
            {
                string defaultValue = GetTypeDefault(returnType);
                builder.AppendLine(defaultValue);
            }
            builder.AppendLine("ret");
        }

        public void Visit(CallStatementNode node)
        {
            VerifyCall(node);
            var procedureName = node[0].AnchorToken.Lexeme;
            Type type = GetSymbol(procedureName).type;
            if (type != Type.VOID)
            {
                builder.AppendLine("pop");
            }
        }
        public void Visit(CallNode node)
        {
            VerifyCall(node);
        }

        // private Type GetLiteralNodeType(IntegerNode node)
        // {
        //     return Type.INT;
        // }
        // private Type GetLiteralNodeType(BooleanNode node)
        // {
        //     return Type.BOOL;
        // }
        // private Type GetLiteralNodeType(StringNode node)
        // {
        //     return Type.STRING;
        // }

        private string GetCilType(Type type)
        {
            switch (type)
            {
                case Type.BOOL:
                case Type.INT:
                    return "int32";
                case Type.STRING:
                    return "string";
                case Type.BOOL_LIST:
                case Type.INT_LIST:
                    return "int32[]";
                case Type.STRING_LIST:
                    return "string[]";
            }
            throw new Exception($"Could not find CIL type for: {type}");
        }
        // private string GetLoadCilType(){
        //     switch (type)
        //     {
        //         case Type.BOOL:
        //         case Type.INT:
        //             return "ldc.i4";
        //         case Type.STRING:
        //             return "ldstr";
        //     }
        // }

        private string GetTypeDefault(Type type)
        {
            switch (type)
            {
                case Type.BOOL:
                case Type.INT:
                    return "ldc.i4.0";
                case Type.STRING:
                    return "ldstr \"\"";
                case Type.BOOL_LIST:
                case Type.INT_LIST:
                    return "ldc.i4.0\nnewarr int32";
                case Type.STRING_LIST:
                    return "ldc.i4.0\nnewarr string";
            }
            throw new Exception($"Could not find CIL type for: {type}");
        }

        private void VerifyCondition(Node node)
        {
            Type conditionType = Visit((dynamic)node[0]);
            if (conditionType != Type.BOOL)
            {
                throw new SemanticError($"Condition has to be of type {Type.BOOL} but got {conditionType}",
                    node.AnchorToken);
            }
        }

        private void VerifyCall(Node node)
        {
            string procedureName = node[0].AnchorToken.Lexeme;
            var symbol = procedureTable[procedureName];
            string returnType = GetCilType(symbol.type);
            string _prefix = "";

            if (symbol.isPredefined)
            {
                _prefix = "['ChimeraLib']'Chimera'.Lib";
            }
            else
            {
                _prefix = "['Chimera']'ChimeraProgram'";
            }
            builder.AppendLine($"call {returnType} class {_prefix}::'{procedureName}'()");
        }

        void VisitChildren(Node node, int skip = 0, int take = 0)
        {
            skip = Math.Min(skip, node.Count());
            if (take == 0)
            {
                take = node.Count() - skip;
            }
            foreach (var n in node.Skip(skip).Take(take))
            {
                Visit((dynamic)n);
            }
        }

        void VisitBinaryOperator(Node node, Type type)
        {
            if (Visit((dynamic)node[0]) != type ||
                Visit((dynamic)node[1]) != type)
            {
                throw new SemanticError(
                    System.String.Format(
                        "Operator {0} requires two operands of type {1}",
                        node.AnchorToken.Lexeme,
                        type),
                    node.AnchorToken);
            }
        }

        void VisitBinaryIntOrBoolOperator(Node node)
        {
            Type type = Visit((dynamic)node[0]);
            switch (type)
            {
                case Type.INT:
                case Type.BOOL:
                    VisitBinaryOperator(node, type);
                    break;
                default:
                    throw new SemanticError($"Operator {node.AnchorToken.Lexeme} requires one "
                                            + $"of {Type.BOOL} or {Type.INT}", node.AnchorToken);
            }
        }

        void AddSymbolToScope(string key, Type type, Kind kind, int pos = -1)
        {
            SymbolTable table;
            if (currentScope.Length == 0)
            {
                table = symbolTable;
            }
            else
            {
                table = procedureTable[currentScope].symbols;
            }
            table[key] = new SymbolTable.Row(type, kind, pos);
        }

        SymbolTable.Row GetSymbol(string key)
        {
            // Try current scope first, then global
            if (currentScope.Length > 0 && procedureTable[currentScope].symbols.Contains(key))
            {
                return procedureTable[currentScope].symbols[key];
            }
            else if (symbolTable.Contains(key))
            {
                return symbolTable[key];
            }
            return null;
        }

        bool CurrentScopeHasSymbol(string key)
        {
            SymbolTable table;
            if (currentScope.Length == 0)
            {
                table = symbolTable;
            }
            else
            {
                table = procedureTable[currentScope].symbols;
            }
            return table.Contains(key);
        }
    }
}
